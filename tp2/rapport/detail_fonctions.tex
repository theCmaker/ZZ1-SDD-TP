Dans cette partie, sont décrits les algorithmes de principe associés aux fonctions écrites en langage C, ainsi qu'un lexique concernant les variables intermédiaires des fonctions.

Le lexique des variable d'entrée, sortie et entrée/sortie sont disponibles dans le code source directement.

\section{Gestion de la pile}
  La gestion de la pile s'effectue grace aux fichiers \textit{stack.c} et \textit{stack.h}.
  
  \subsection{init}
  \subsection{supp}
  \subsection{empty}
  \subsection{full}
  \subsection{pop}
  \subsection{top}
  \subsection{push}

\section{Dérecursification de la fonction}
  La fonction récursive ainsi que sa version itérée se trouvent dans les fichiers \textit{truc.c} et \textit{truc.h}.
  \subsection{TRUC}
    Cette fonction étant l'énoncé du TP, nous ne détaillerons ainsi ne le principe ni les variables utilisées dans cet algorihtme.
    
  \subsection{truc\_iter}
    \begin{algo}[informal] %principe
      \ALGO{truc\_iter (Principe)}
      \BEGIN
        \STATE{Copie des paramètres d'entré dans des variables locales, sl et il}
        \STATE{Initialisation de la pile de la même taille que le tableau statique}
        \REPEAT
          \WHILE{sl > 0 \ANDTHEN il <= N}
            \STATE{On push sl dans la pile}
            \STATE{On push il dans la pile}
            \STATE{sl = sl - P[il]}
            \STATE{On incrémente il}
          \ENDWHILE
          \IF{sl = 0}
            \STATE{Le booléen de retour est à Vrai}
            \WHILE{la pile n'est pas vide}
              \STATE{On récupère il et sl à partir de la pile}
              \STATE{On affiche P[il]}
            \ENDWHILE
          \ELSE
            \STATE{Le booléen de retour est à Faux}
            \IF{la pile n'est pas vide}
              \STATE{On récupère il est sl à partir de la pile}
              \STATE{On incrémente il}
            \ENDIF
          \ENDIF
        \ENDREPEAT[while]{la pile n'est pas vide}
        \RETURN{Booléen de retour}
      \END
    \end{algo}

    \begin{algo}[informal] %lexique
      \VAR
        \DECLVAR{sl}{copie locale du nombre s passé en paramètre. Représente le nombre à décomposer}
        \DECLVAR{il}{copie locale du nombre i passé en paramètre. Représente le nombre d'entiers du tableau à utiliser pour décomposer s}
        \DECLVAR{r}{booléen de retour, indique 1 si on a obtenue la somme s, 0 sinon}
        \DECLVAR{p}{pile}
        \DECLVAR{P}{tableau d'entiers, défini statiquement}
        \DECLVAR{N}{taille du tableau P}
      \ENDVAR
    \end{algo}
